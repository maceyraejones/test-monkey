{"ast":null,"code":"var _regeneratorRuntime = require(\"C:\\\\Users\\\\csis\\\\Desktop\\\\testing\\\\react-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\csis\\\\Desktop\\\\testing\\\\react-frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\n/* global WebKitCSSMatrix */\nvar React = require('react');\n\nvar sleep = require('p-sleep');\n\nvar settings = {\n  snapBackDuration: 300,\n  maxTilt: 5,\n  bouncePower: 0.2,\n  swipeThreshold: 300 // px/s\n\n};\n\nvar getElementSize = function getElementSize(element) {\n  var elementStyles = window.getComputedStyle(element);\n  var widthString = elementStyles.getPropertyValue('width');\n  var width = Number(widthString.split('px')[0]);\n  var heightString = elementStyles.getPropertyValue('height');\n  var height = Number(heightString.split('px')[0]);\n  return {\n    x: width,\n    y: height\n  };\n};\n\nvar pythagoras = function pythagoras(x, y) {\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n};\n\nvar normalize = function normalize(vector) {\n  var multiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  return {\n    x: vector.x * multiplier / length,\n    y: vector.y * multiplier / length\n  };\n};\n\nvar animateOut = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(element, speed) {\n    var easeIn,\n        startPos,\n        bodySize,\n        diagonal,\n        velocity,\n        time,\n        multiplier,\n        translateString,\n        rotateString,\n        rotationPower,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            easeIn = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n            startPos = getTranslate(element);\n            bodySize = getElementSize(document.body);\n            diagonal = pythagoras(bodySize.x, bodySize.y);\n            velocity = pythagoras(speed.x, speed.y);\n            time = diagonal / velocity;\n            multiplier = diagonal / velocity;\n            translateString = translationString(speed.x * multiplier + startPos.x, -speed.y * multiplier + startPos.y);\n            rotateString = '';\n            rotationPower = 200;\n\n            if (easeIn) {\n              element.style.transition = 'ease ' + time + 's';\n            } else {\n              element.style.transition = 'ease-out ' + time + 's';\n            }\n\n            if (getRotation(element) === 0) {\n              rotateString = rotationString((Math.random() - 0.5) * rotationPower);\n            } else if (getRotation(element) > 0) {\n              rotateString = rotationString(Math.random() * rotationPower / 2 + getRotation(element));\n            } else {\n              rotateString = rotationString((Math.random() - 1) * rotationPower / 2 + getRotation(element));\n            }\n\n            element.style.transform = translateString + rotateString;\n            _context.next = 15;\n            return sleep(time * 1000);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function animateOut(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar animateBack = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(element) {\n    var startingPoint, translation, rotation;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            element.style.transition = settings.snapBackDuration + 'ms';\n            startingPoint = getTranslate(element);\n            translation = translationString(startingPoint.x * -settings.bouncePower, startingPoint.y * -settings.bouncePower);\n            rotation = rotationString(getRotation(element) * -settings.bouncePower);\n            element.style.transform = translation + rotation;\n            _context2.next = 7;\n            return sleep(settings.snapBackDuration * 0.75);\n\n          case 7:\n            element.style.transform = 'none';\n            _context2.next = 10;\n            return sleep(settings.snapBackDuration);\n\n          case 10:\n            element.style.transition = '10ms';\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function animateBack(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getSwipeDirection = function getSwipeDirection(property) {\n  if (Math.abs(property.x) > Math.abs(property.y)) {\n    if (property.x > settings.swipeThreshold) {\n      return 'right';\n    } else if (property.x < -settings.swipeThreshold) {\n      return 'left';\n    }\n  } else {\n    if (property.y > settings.swipeThreshold) {\n      return 'up';\n    } else if (property.y < -settings.swipeThreshold) {\n      return 'down';\n    }\n  }\n\n  return 'none';\n};\n\nvar calcSpeed = function calcSpeed(oldLocation, newLocation) {\n  var dx = newLocation.x - oldLocation.x;\n  var dy = oldLocation.y - newLocation.y;\n  var dt = (newLocation.time - oldLocation.time) / 1000;\n  return {\n    x: dx / dt,\n    y: dy / dt\n  };\n};\n\nvar translationString = function translationString(x, y) {\n  var translation = 'translate(' + x + 'px, ' + y + 'px)';\n  return translation;\n};\n\nvar rotationString = function rotationString(rot) {\n  var rotation = 'rotate(' + rot + 'deg)';\n  return rotation;\n};\n\nvar getTranslate = function getTranslate(element) {\n  var style = window.getComputedStyle(element);\n  var matrix = new WebKitCSSMatrix(style.webkitTransform);\n  var ans = {\n    x: matrix.m41,\n    y: -matrix.m42\n  };\n  return ans;\n};\n\nvar getRotation = function getRotation(element) {\n  var style = window.getComputedStyle(element);\n  var matrix = new WebKitCSSMatrix(style.webkitTransform);\n  var ans = -Math.asin(matrix.m21) / (2 * Math.PI) * 360;\n  return ans;\n};\n\nvar dragableTouchmove = function dragableTouchmove(coordinates, element, offset, lastLocation) {\n  var pos = {\n    x: coordinates.x + offset.x,\n    y: coordinates.y + offset.y\n  };\n  var newLocation = {\n    x: pos.x,\n    y: pos.y,\n    time: new Date().getTime()\n  };\n  var translation = translationString(pos.x, pos.y);\n  var rotCalc = calcSpeed(lastLocation, newLocation).x / 1000;\n  var rotation = rotationString(rotCalc * settings.maxTilt);\n  element.style.transform = translation + rotation;\n  return newLocation;\n};\n\nvar touchCoordinatesFromEvent = function touchCoordinatesFromEvent(e) {\n  var touchLocation = e.targetTouches[0];\n  return {\n    x: touchLocation.clientX,\n    y: touchLocation.clientY\n  };\n};\n\nvar mouseCoordinatesFromEvent = function mouseCoordinatesFromEvent(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n};\n\nvar TinderCard = React.forwardRef(function (_ref3, ref) {\n  var _ref3$flickOnSwipe = _ref3.flickOnSwipe,\n      flickOnSwipe = _ref3$flickOnSwipe === void 0 ? true : _ref3$flickOnSwipe,\n      children = _ref3.children,\n      onSwipe = _ref3.onSwipe,\n      onCardLeftScreen = _ref3.onCardLeftScreen,\n      className = _ref3.className,\n      _ref3$preventSwipe = _ref3.preventSwipe,\n      preventSwipe = _ref3$preventSwipe === void 0 ? [] : _ref3$preventSwipe,\n      _ref3$swipeRequiremen = _ref3.swipeRequirementType,\n      swipeRequirementType = _ref3$swipeRequiremen === void 0 ? 'velocity' : _ref3$swipeRequiremen,\n      _ref3$swipeThreshold = _ref3.swipeThreshold,\n      swipeThreshold = _ref3$swipeThreshold === void 0 ? settings.swipeThreshold : _ref3$swipeThreshold,\n      onSwipeRequirementFulfilled = _ref3.onSwipeRequirementFulfilled,\n      onSwipeRequirementUnfulfilled = _ref3.onSwipeRequirementUnfulfilled;\n  settings.swipeThreshold = swipeThreshold;\n  var swipeAlreadyReleased = React.useRef(false);\n  var element = React.useRef();\n  React.useImperativeHandle(ref, function () {\n    return {\n      swipe: function () {\n        var _swipe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n          var dir,\n              power,\n              disturbance,\n              _args3 = arguments;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  dir = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 'right';\n                  if (onSwipe) onSwipe(dir);\n                  power = 1000;\n                  disturbance = (Math.random() - 0.5) * 100;\n\n                  if (!(dir === 'right')) {\n                    _context3.next = 9;\n                    break;\n                  }\n\n                  _context3.next = 7;\n                  return animateOut(element.current, {\n                    x: power,\n                    y: disturbance\n                  }, true);\n\n                case 7:\n                  _context3.next = 22;\n                  break;\n\n                case 9:\n                  if (!(dir === 'left')) {\n                    _context3.next = 14;\n                    break;\n                  }\n\n                  _context3.next = 12;\n                  return animateOut(element.current, {\n                    x: -power,\n                    y: disturbance\n                  }, true);\n\n                case 12:\n                  _context3.next = 22;\n                  break;\n\n                case 14:\n                  if (!(dir === 'up')) {\n                    _context3.next = 19;\n                    break;\n                  }\n\n                  _context3.next = 17;\n                  return animateOut(element.current, {\n                    x: disturbance,\n                    y: power\n                  }, true);\n\n                case 17:\n                  _context3.next = 22;\n                  break;\n\n                case 19:\n                  if (!(dir === 'down')) {\n                    _context3.next = 22;\n                    break;\n                  }\n\n                  _context3.next = 22;\n                  return animateOut(element.current, {\n                    x: disturbance,\n                    y: -power\n                  }, true);\n\n                case 22:\n                  element.current.style.display = 'none';\n                  if (onCardLeftScreen) onCardLeftScreen(dir);\n\n                case 24:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        function swipe() {\n          return _swipe.apply(this, arguments);\n        }\n\n        return swipe;\n      }(),\n      restoreCard: function () {\n        var _restoreCard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  element.current.style.display = 'block';\n                  _context4.next = 3;\n                  return animateBack(element.current);\n\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        function restoreCard() {\n          return _restoreCard.apply(this, arguments);\n        }\n\n        return restoreCard;\n      }()\n    };\n  });\n  var handleSwipeReleased = React.useCallback( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(element, speed) {\n      var currentPostion, dir, outVelocity;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!swipeAlreadyReleased.current) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 2:\n              swipeAlreadyReleased.current = true;\n              currentPostion = getTranslate(element); // Check if this is a swipe\n\n              dir = getSwipeDirection(swipeRequirementType === 'velocity' ? speed : currentPostion);\n\n              if (!(dir !== 'none')) {\n                _context5.next = 15;\n                break;\n              }\n\n              if (onSwipe) onSwipe(dir);\n\n              if (!flickOnSwipe) {\n                _context5.next = 15;\n                break;\n              }\n\n              if (preventSwipe.includes(dir)) {\n                _context5.next = 15;\n                break;\n              }\n\n              outVelocity = swipeRequirementType === 'velocity' ? speed : normalize(currentPostion, 600);\n              _context5.next = 12;\n              return animateOut(element, outVelocity);\n\n            case 12:\n              element.style.display = 'none';\n              if (onCardLeftScreen) onCardLeftScreen(dir);\n              return _context5.abrupt(\"return\");\n\n            case 15:\n              // Card was not flicked away, animate back to start\n              animateBack(element);\n\n            case 16:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x4, _x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [swipeAlreadyReleased, flickOnSwipe, onSwipe, onCardLeftScreen, preventSwipe, swipeRequirementType]);\n  var handleSwipeStart = React.useCallback(function () {\n    swipeAlreadyReleased.current = false;\n  }, [swipeAlreadyReleased]);\n  React.useLayoutEffect(function () {\n    var offset = {\n      x: null,\n      y: null\n    };\n    var speed = {\n      x: 0,\n      y: 0\n    };\n    var lastLocation = {\n      x: 0,\n      y: 0,\n      time: new Date().getTime()\n    };\n    var mouseIsClicked = false;\n    var swipeThresholdFulfilledDirection = 'none';\n    element.current.addEventListener('touchstart', function (ev) {\n      ev.preventDefault();\n      handleSwipeStart();\n      offset = {\n        x: -touchCoordinatesFromEvent(ev).x,\n        y: -touchCoordinatesFromEvent(ev).y\n      };\n    });\n    element.current.addEventListener('mousedown', function (ev) {\n      ev.preventDefault();\n      mouseIsClicked = true;\n      handleSwipeStart();\n      offset = {\n        x: -mouseCoordinatesFromEvent(ev).x,\n        y: -mouseCoordinatesFromEvent(ev).y\n      };\n    });\n\n    var handleMove = function handleMove(coordinates) {\n      // Check fulfillment\n      if (onSwipeRequirementFulfilled || onSwipeRequirementUnfulfilled) {\n        var dir = getSwipeDirection(swipeRequirementType === 'velocity' ? speed : getTranslate(element.current));\n\n        if (dir !== swipeThresholdFulfilledDirection) {\n          swipeThresholdFulfilledDirection = dir;\n\n          if (swipeThresholdFulfilledDirection === 'none') {\n            if (onSwipeRequirementUnfulfilled) onSwipeRequirementUnfulfilled();\n          } else {\n            if (onSwipeRequirementFulfilled) onSwipeRequirementFulfilled(dir);\n          }\n        }\n      } // Move\n\n\n      var newLocation = dragableTouchmove(coordinates, element.current, offset, lastLocation);\n      speed = calcSpeed(lastLocation, newLocation);\n      lastLocation = newLocation;\n    };\n\n    element.current.addEventListener('touchmove', function (ev) {\n      ev.preventDefault();\n      handleMove(touchCoordinatesFromEvent(ev));\n    });\n    element.current.addEventListener('mousemove', function (ev) {\n      ev.preventDefault();\n\n      if (mouseIsClicked) {\n        handleMove(mouseCoordinatesFromEvent(ev));\n      }\n    });\n    element.current.addEventListener('touchend', function (ev) {\n      ev.preventDefault();\n      handleSwipeReleased(element.current, speed);\n    });\n    element.current.addEventListener('mouseup', function (ev) {\n      if (mouseIsClicked) {\n        ev.preventDefault();\n        mouseIsClicked = false;\n        handleSwipeReleased(element.current, speed);\n      }\n    });\n    element.current.addEventListener('mouseleave', function (ev) {\n      if (mouseIsClicked) {\n        ev.preventDefault();\n        mouseIsClicked = false;\n        handleSwipeReleased(element.current, speed);\n      }\n    });\n  }, []); // TODO fix so swipeRequirementType can be changed on the fly. Pass as dependency cleanup eventlisteners and update new eventlisteners.\n\n  return React.createElement('div', {\n    ref: element,\n    className: className\n  }, children);\n});\nmodule.exports = TinderCard;","map":null,"metadata":{},"sourceType":"script"}